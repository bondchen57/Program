<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>HTML5 Canvas</title>
    <script src="../js/three.min.js"></script>
</head>
<body>
    <script>
        //定義全域變數
        var camera, scene, renderer, geometry, mesh, mesh2;

        init();
        animate();

        //該函數用於初始化工作
        function init(){
            //建立繪製器，這個繪製器就是 canvas 元素，並判斷是否支援 WebGLRenderingContext
            if(window.WebGLRenderingContext){
                renderer = new THREE.WebGLRenderer();
            }else{
                renderer = new THREE.CanvasRenderer();
            }

            //設定場景大小
            renderer.setSize(640, 480);     

            //建立透視投影相機
            camera = new THREE.PerspectiveCamera(55, 640/480, 1, 10000);
            
            //相機初始位置為原點，將相機拉回來一些，這樣才能看到原點
            camera.position.z = 1000;       

            //建立場景
            scene = new THREE.Scene();

            //建立一個根據平面曲線切削成幾何體物件：方程式、參數slice、參數stacks
            //注意會圍繞著 y 軸進行
            //THREE.ParametricGeometry = function(func, slice, stacks)
            
            //先建立球體方程式
            var slices = 32,    //經度分段數
                stacks = 32;    //緯度分段數
            function sphere(u, v){
                u *= Math.PI;
                v *= 2 * Math.PI;
                var x = Math.sin(u) * Math.cos(v);
                var y = Math.cos(u);
                var z = -Math.sin(u) * Math.sin(v);
                return (new THREE.Vector3(x*200, y*200, z*200));
            }

            //建立克萊因瓶方程式（可參考網路上外掛：https://threejs.org/examples/js/ParametricGeometries.js）
            function klein(u, v){         
                u *= Math.PI;
                v *= 2 * Math.PI;
                u = u * 2;
                var x, y, z;

                if (u < Math.PI) {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
                    z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
                } else {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
                    z = -8 * Math.sin(u);
                }
                y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
        
                return (new THREE.Vector3(x*20, y*20, z*20));
            }

            //建立莫比烏斯帶方程式
            function mobiusStrip(u, v){
                u = u - 0.5;
                var v = 2 * Math.PI * v;
                var x, y, z;        
                var a = 2;
        
                x = Math.cos(v) * (a + u * Math.cos(v / 2));
                y = Math.sin(v) * (a + u * Math.cos(v / 2));
                z = u * Math.sin(v / 2);
        
                return (new THREE.Vector3(x*100, y*100, z*100));
            }

            //建立莫比烏斯環方程式
            function mobiusStripVolumetric(u, v){
                u *= Math.PI;
                v *= 2 * Math.PI;
                u = u * 2;
                var phi = u / 2;
                var major = 2.25, a = 0.125, b = 0.65;
                var x, y, z;
        
                x = a * Math.cos(v) * Math.cos(phi) - b * Math.sin(v) * Math.sin(phi);
                z = a * Math.cos(v) * Math.sin(phi) + b * Math.sin(v) * Math.cos(phi);
                y = (major + x) * Math.sin(u);
                x = (major + x) * Math.cos(u);
        
                return (new THREE.Vector3(x*100, y*100, z*100));
            }

            //建立三葉結方程式???????
            function trefoilKnot(u, v){
                u *= Math.PI;
                v *= 2 * Math.PI;
                var x, y, z;
        
                x = (2 + Math.cos(3*v)) * Math.cos(2*v);
                y = (2 + Math.cos(3*v)) * Math.sin(2*v);
                z = Math.sin(3*v);
        
                return (new THREE.Vector3(x*100, y*100, z*100));
            }

            geometry = new THREE.ParametricGeometry(klein, slices, stacks);

            //使用顏色建立一個材質，呈現線方塊圖
            var material = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});
            var material2 = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: true, opacity: 0.7});

            //根據模型和材質建立曲面
            mesh = new THREE.Mesh(geometry, material);
            mesh2 = new THREE.Mesh(geometry, material2);

            //將曲面增加到場景中
            scene.add(mesh);
            scene.add(mesh2);

            //將繪製器加到 DOM 結構中
            document.body.appendChild(renderer.domElement); 
        }
        
        //該函數用於實現一個計時器動畫
        function animate(){
            //定時執行 animate() 函數
            requestAnimationFrame(animate);

            //旋轉
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.02;

            mesh2.rotation.x += 0.01;
            mesh2.rotation.y += 0.02;

            //使用指定的場景和相機繪製
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>