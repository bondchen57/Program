<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>HTML5 Canvas</title>
    <script src="../js/three.min.js"></script>
</head>
<body>
    <script>
        //定義全域變數
        var camera, scene, renderer, geometry, mesh;

        init();
        animate();

        //該函數用於初始化工作
        function init(){
            //建立繪製器，這個繪製器就是 canvas 元素，並判斷是否支援 WebGLRenderingContext
            if(window.WebGLRenderingContext){
                renderer = new THREE.WebGLRenderer();
            }else{
                renderer = new THREE.CanvasRenderer();
            }

            //設定場景大小
            renderer.setSize(640, 480);     

            //建立透視投影相機
            camera = new THREE.PerspectiveCamera(55, 640/480, 1, 10000);
            
            //相機初始位置為原點，將相機拉回來一些，這樣才能看到原點
            camera.position.z = 1000;       

            //建立場景
            scene = new THREE.Scene();

            //定義一個頂點陣列，包含 24 個座標，實際上組成一個立方體
            var vertices = [
                //Front face
                -200, -200,  200,
                 200, -200,  200,
                 200,  200,  200,
                -200,  200,  200,

                //Back face
                -200, -200, -200,
                -200,  200, -200,
                 200,  200, -200,
                 200, -200, -200,

                //Top face
                -200,  200, -200,
                -200,  200,  200,
                 200,  200,  200,
                 200,  200, -200,

                //Bottom face
                -200, -200, -200,
                 200, -200, -200,
                 200, -200,  200,
                -200, -200,  200,

                //Right face
                 200, -200, -200,
                 200,  200, -200,
                 200,  200,  200,
                 200, -200,  200,

                //Left face
                -200, -200, -200,
                -200, -200,  200,
                -200,  200,  200,
                -200,  200, -200
            ];
        
            //建立顏色陣列對映每個頂點
            var colors = [
                [1.0, 0.0, 0.0, 1.0],   //Front face
                [1.0, 1.0, 0.0, 1.0],   //Back face
                [0.0, 1.0, 0.0, 1.0],   //Top face
                [0.0, 1.0, 1.0, 1.0],   //Bottom face
                [1.0, 0.0, 1.0, 1.0],   //Right face
                [0.0, 0.0, 1.0, 1.0]    //Left face
            ];
            var vertexColors = [];
            for(var i in colors){
                var color = colors[i];
                for(var j = 0; j < 4; j++){
                    vertexColors = vertexColors.concat(color);
                }
            }

            //法線陣列，對應每個頂點
            var vertexNormals = [
                //Front face
                0.0, 0.0, 1.0,
                0.0, 0.0, 1.0,
                0.0, 0.0, 1.0,
                0.0, 0.0, 1.0,

                //Back face
                0.0, 0.0, -1.0,
                0.0, 0.0, -1.0,
                0.0, 0.0, -1.0,
                0.0, 0.0, -1.0,

                //Top face
                0.0, 1.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 1.0, 0.0,

                //Bottom face
                0.0, -1.0, 0.0,
                0.0, -1.0, 0.0,
                0.0, -1.0, 0.0,
                0.0, -1.0, 0.0,

                //Right face
                1.0, 0.0, 0.0,
                1.0, 0.0, 0.0,
                1.0, 0.0, 0.0,
                1.0, 0.0, 0.0,

                //Left face
                -1.0, 0.0, 0.0,
                -1.0, 0.0, 0.0,
                -1.0, 0.0, 0.0,
                -1.0, 0.0, 0.0
            ];

            //定義一個索引陣列，參考頂點陣列中的座標
            var indices = [
                 0,  1,  2,      0,  2,  3,     //Front face
                 4,  5,  6,      4,  6,  7,     //Back face
                 8,  9, 10,      8, 10, 11,     //Top face
                12, 13, 14,     12, 14, 15,     //Bottom face
                16, 17, 18,     16, 18, 19,     //Right face
                20, 21, 22,     20, 22, 23      //Left face
            ];
            
            //定義一個 BufferGeometry
            geometry = new THREE.BufferGeometry();

            //設定模型的各項資料 - 舊版寫法
            // geometry.attributes = {
            //     index:{                     //頂點索引
            //         itemSize:1,
            //         array:new Uint16Array(indices)      
            //     },
            //     position:{                  //頂點座標
            //         itemSize:3,
            //         array:new Float32Array(vertices)
            //     },
            //     normal:{                    //頂點法線向量
            //         itemSize:3,
            //         array:new Float32Array(vertexNormals)
            //     },
            //     color:{                     //頂點顏色
            //         itemSize:4,
            //         array:new Float32Array(vertexColors)
            //     }
            // };
            //itemSize 是單一資料的大小，例如頂點通常是 3 個陣列元素組成一個頂點資料，而顏色如果使用 RGBA，則是 4 個陣列元素組成一個顏色資料。
            //注意，如果指定了 index，就表示使用原生 API 的 drawElements() 方法繪製，如果沒有定義 index，就表示使用原生 API 的 drawArrays() 方法繪製。
            
            //設定模型的各項資料 - 新版寫法
            geometry.addAttribute('index', new THREE.BufferAttribute(new Uint16Array(indices), 1));
            geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(vertexNormals), 3));
            geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(vertexColors), 4));

            //定義 offsets
            var offset = {
                start: 0,       //offset
                index: 0,       //start
                count: 36       //count
            };
            geometry.groups.push(offset);

            //使用顏色建立材質
            var material = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});

            //根據模型和材質建立曲面
            mesh = new THREE.Mesh(geometry, material);

            //將曲面增加到場景中
            scene.add(mesh);

            //將繪製器加到 DOM 結構中
            document.body.appendChild(renderer.domElement); 
        }

        //該函數用於實現一個計時器動畫
        function animate(){
            //定時執行 animate() 函數
            requestAnimationFrame(animate);

            //旋轉
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.02;

            //使用指定的場景和相機繪製
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>